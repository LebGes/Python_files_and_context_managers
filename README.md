# Python_files_and_context_managers
Домашняя работа по работе с файлами и контекстными менеджерами

# Задача
- В качестве практической работы необходимо нарисовать блок-схемы работы алгоритма решения задач и загрузить в свой репозиторий в течение дня.
- В качестве домашней работы необходимо реализовать программы по ранее созданным алгоритмам решения задач на языке Python и загрузить в свой репозиторий до крайнего срока.

Даты сдачи оговариваются в канале группы.

# Домашнее Задание
Создать классы Сериализации и Десериализации данных для каталога товаров:
* В качестве каталога товаров можно использовать класс карточки товара из предыдущего домашнего задания
* Данные должны считываться из файлов формата JSON/XML при их наличии, либо могут быть получены из файлов формата .txt или .excel
* Данные должны записываться в файлы формата JSON/XML и использоваться в рамках программы в качестве системы хранения данных
* При изменении карточки товара должна производиться перезапись данных в JSON/XML
* При добавлении новой карточки товара в JSON/XML должна добавиться новая запись
* При удалении карточки товара запись должна удаляться и из JSON/XML

# Практическое Задание
Нарисовать блок-схему взаимодействия с файлами, согласно заданию

# Теоретическая справка
**Файл** — это именованная область на носителе информации (диск, SSD и т.д.), предназначенная для хранения данных.

### Что такое файл с точки зрения ОС?
Файл — это:
* Имя (например: data.txt)
* Путь (например: /home/user/data.txt)
* Содержимое (последовательность байтов)
* Метаданные:
  * размер
  * дата создания
  * права доступа
  * владелец

Операционная система управляет файлами через файловую систему.
Главное: файл — это просто последовательность байтов
Для компьютера:
* Файл = набор байтов
Не важно что хранится:
* текст
* картинка
* видео
* JSON
* XML
Всё хранится как байты.
Разница только в том, как мы интерпретируем эти байты.

## Процесс работы с файлами
1. Запрос на открытие
2. Получение дескриптора
3. Работа через буфер
4. Чтение / запись
5. Сброс буфера
6. Закрытие

### Открытие файла
Когда вы пишете:
```
f = open("data.txt", "r")
```
Происходит:
* Программа вызывает системный вызов ОС
ОС:
* Ищет файл в файловой системе
* Проверяет права доступа
* Проверяет режим (r/w/a)
Если всё успешно — ОС создаёт файловый дескриптор

### Что такое файловый дескриптор?
Файловый дескриптор — это числовой идентификатор открытого файла внутри операционной системы.

Python-объект f внутри содержит ссылку на этот дескриптор.

Это важно:
* ОС отслеживает все открытые файлы
* У процесса есть лимит открытых файлов

Если файл не закрывать — можно получить ошибку:
```
Too many open files
```

### Буферизация

Когда вы читаете или записываете файл, данные не всегда сразу идут на диск.

Используется буфер — область памяти, потому что:
* Доступ к диску медленный
* RAM очень быстрая

При записи:
#### Программа → Буфер (RAM) → Диск
Сначала данные попадают в буфер, а только потом — на диск.

### Когда буфер сбрасывается?
* Когда буфер заполняется
* При вызове flush()
* При закрытии файла
* Иногда автоматически

Пример:
```
f.write("Hello")
f.flush()  # принудительная запись на диск
```

### Чтение файла — что происходит?
Когда вы читаете файл:
```
data = f.read()
```
Происходит такой процесс:
#### Диск → Буфер ОС → Буфер Python → Переменная
Сначала данные читаются блоками в память, а затем передаются в программу.

### Указатель позиции (file pointer)
У каждого открытого файла есть позиция чтения/записи.
Пример:
```
f.read(5)
```
Файл прочитает первые 5 байтов и указатель сдвинется вперёд.

Можно управлять позицией:
```
f.seek(0)   # перейти в начало
f.tell()    # узнать текущую позицию
```
Это особенно важно при работе с бинарными файлами.

### Что происходит при закрытии?
```
f.close()
```
ОС:
* Сбрасывает буфер
* Освобождает дескриптор
* Удаляет файл из списка открытых

Если не закрыть файл:
* Данные могут не записаться полностью
* Возможны утечки ресурсов

Для таких случаев используется менеджер контекста:
```
with open("file.txt") as f:
```

### Права доступа
Когда файл открывается:
* ОС проверяет права
* Если нет прав → исключение

### Режимы открытия — что реально меняется?
"r":
* Только чтение
* Указатель в начале

"w":
* Очищает файл
* Создаёт новый если нет

"a":
* Указатель в конце
* Данные только добавляются

"rb", "wb":
* Без преобразования кодировки
* Работа с байтами

### Что может пойти не так?
При работе с файлами возможны:
* FileNotFoundError
* PermissionError
* IsADirectoryError
* Disk full
* Corrupted file
* Encoding error

Поэтому используется:
```
try:
    ...
except Exception as e:
    print(e)
```


